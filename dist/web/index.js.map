{"version":3,"sources":["webpack://PickHtmlElement/./src/index.ts"],"names":["create","customOptions","defaultOptions","defaultCreateOptions","instance","init","destroy","isActive"],"mappings":"uHA6bS,EAAAA,OAjCOC,IAEd,MAAMC,EAAiB,8FAAOC,qBACd,OAAH,wBACRD,GACAD,GAGL,IAAIG,EAAW,KAEf,MAAO,CACLC,KAAM,KACAD,GACFA,EAASE,WAObC,SAAU,IACY,OAAbH,EAETE,QAAS,KACHF,IAGFA,EAAW,S","file":"index.js","sourcesContent":["// import getCssSelector from 'css-selector-generator'\n// import { debounce } from 'debounce'\n// import pick from 'lodash/pick'\n// import values from 'lodash/values'\n// import { createBrush } from './elements/createBrush'\n// import { createGlass } from './elements/createGlass'\n// import { createPageElementHighlight } from './elements/createPageElementHighlight'\n// import { createTooltips } from './elements/createTooltips'\n// import {\n//   CreateBrushReturn,\n//   CreatePageElementHighlightReturn,\n//   ElementSelectorChangeCallback,\n//   HandleBrushDecrease,\n//   HandleBrushDecreaseResponse,\n//   HandleBrushIncrease,\n//   HandleBrushIncreaseResponse,\n//   InitOptions,\n//   State\n// } from './types'\n\n// const scriptKey = 'pickHtmlElementScript'\n// const scriptOptionsKey = 'pickHtmlElementScriptOptions'\n// const elementSelectEventName = 'pickHtmlElementScriptElementSelect'\n\n// const getSelector = (element): string => {\n//   return getCssSelector(element, {\n//     // selectors: ['class', 'tag'],\n//     selectors: ['id', 'class', 'attribute', 'nthchild', 'nthoftype'],\n//     combineWithinSelector: true,\n//     combineBetweenSelectors: true\n//     // includeTag: true\n//   })\n// }\n\n// const findElementFromBrush = (\n//   viewportX: number,\n//   viewportY: number,\n//   pageX: number,\n//   pageY: number,\n//   scrollLeft: number,\n//   scrollTop: number,\n//   brushRadius: number\n// ): Element => {\n//   const elements = document.elementsFromPoint(viewportX, viewportY)\n//   const brushX = pageX\n//   const brushY = pageY\n\n//   const element =\n//     elements.find((element) => {\n//       const elementRectangle = element.getBoundingClientRect()\n\n//       return (\n//         brushX - brushRadius >= elementRectangle.x + scrollLeft &&\n//         brushX + brushRadius <= elementRectangle.x + scrollLeft + elementRectangle.width &&\n//         brushY - brushRadius >= elementRectangle.y + scrollTop &&\n//         brushY + brushRadius <= elementRectangle.y + scrollTop + elementRectangle.height\n//       )\n//     }) || document.body\n\n//   return element\n// }\n\n// const highlightElement = (\n//   element: Element,\n//   scrollLeft: number,\n//   scrollTop: number,\n//   pageElementHighlight: CreatePageElementHighlightReturn\n// ): void => {\n//   const elementBoundingRect = element.getBoundingClientRect()\n\n//   pageElementHighlight.setPosition(elementBoundingRect.left + scrollLeft, elementBoundingRect.top + scrollTop)\n//   pageElementHighlight.setDimensions(elementBoundingRect.width, elementBoundingRect.height)\n// }\n\n// const updatePickElement = (\n//   event: MouseEvent,\n//   brushRadius: number,\n//   pageElementHighlight: CreatePageElementHighlightReturn,\n//   elementSelectorChangeCallback: ElementSelectorChangeCallback\n// ): void => {\n//   const pageX = event.pageX\n//   const pageY = event.pageY\n\n//   const viewportX = event.clientX\n//   const viewportY = event.clientY\n\n//   const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft\n//   const scrollTop = window.pageYOffset || document.documentElement.scrollTop\n\n//   const element = findElementFromBrush(viewportX, viewportY, pageX, pageY, scrollLeft, scrollTop, brushRadius)\n\n//   const elementSelector = getSelector(element)\n\n//   const elementFromSelector = document.querySelector(elementSelector)\n\n//   highlightElement(elementFromSelector, scrollLeft, scrollTop, pageElementHighlight)\n\n//   elementSelectorChangeCallback(elementSelector, element)\n// }\n\n// const debouncedUpdatePickElement = debounce(updatePickElement, 200)\n\n// const getBrushRadiusFromMultiplier = (baseBrushRadius: number, radiusMultiplier: number): number =>\n//   baseBrushRadius * (1 / Math.pow(radiusMultiplier, 2))\n\n// const handleBrushDecrease = (options: HandleBrushDecrease): HandleBrushDecreaseResponse => {\n//   const newBrushRadiusMultiplier = options.brushRadiusMultiplier + 0.2\n\n//   if (newBrushRadiusMultiplier < 3) {\n//     const newBrushRadius = getBrushRadiusFromMultiplier(options.baseBrushRadius, newBrushRadiusMultiplier)\n\n//     options.brush.setRadius(newBrushRadius)\n\n//     const brushRadiusMultiplier = newBrushRadiusMultiplier\n\n//     if (options.lastMouseEvent) {\n//       updatePickElement(\n//         options.lastMouseEvent,\n//         options.brush.getRadius(),\n//         options.pageElementHighlight,\n//         options.elementSelectorChangeCallback\n//       )\n//     }\n\n//     return {\n//       brushRadiusMultiplier\n//     }\n//   }\n\n//   return {}\n// }\n\n// const handleBrushRadiusIncrease = (options: HandleBrushIncrease): HandleBrushIncreaseResponse => {\n//   const newBrushRadiusMultiplier = options.brushRadiusMultiplier - 0.2\n\n//   if (newBrushRadiusMultiplier > 0.001) {\n//     const newBrushRadius = getBrushRadiusFromMultiplier(options.baseBrushRadius, newBrushRadiusMultiplier)\n\n//     options.brush.setRadius(newBrushRadius)\n\n//     const brushRadiusMultiplier = newBrushRadiusMultiplier\n\n//     if (options.lastMouseEvent) {\n//       updatePickElement(\n//         options.lastMouseEvent,\n//         options.brush.getRadius(),\n//         options.pageElementHighlight,\n//         options.elementSelectorChangeCallback\n//       )\n//     }\n\n//     return {\n//       brushRadiusMultiplier\n//     }\n//   }\n\n//   return {}\n// }\n\n// const appendAllTo = (instances, parent) => {\n//   instances.forEach((instance) => {\n//     instance.append(parent)\n//   })\n// }\n\n// const removeAll = (instances) => {\n//   instances.forEach((instance) => {\n//     instance.remove()\n//   })\n// }\n\n// const updateBrushPosition = (brush: CreateBrushReturn, x: number, y: number): void => {\n//   brush.setPosition(x, y)\n// }\n\n// const createState = (options): State => {\n//   const { tint, alternativeControls } = options\n\n//   return {\n//     brush: createBrush({ color: tint }),\n//     glass: createGlass(),\n//     pageElementHighlight: createPageElementHighlight({ color: tint }),\n//     tooltips: createTooltips({ alternativeControls }),\n//     baseBrushRadius: 50,\n//     brushRadiusMultiplier: 1,\n//     lastMouseEvent: null,\n//     elementSelector: null,\n//     element: null\n//   }\n// }\n\n// const createOnMouseMoveListener = (state: State, updateStateElementSelector) => (event: MouseEvent): void => {\n//   state.lastMouseEvent = event\n//   updateBrushPosition(state.brush, event.pageX, event.pageY)\n//   debouncedUpdatePickElement(event, state.brush.getRadius(), state.pageElementHighlight, updateStateElementSelector)\n\n//   if (state.tooltips.hits(event.clientX, event.clientY)) {\n//     state.tooltips.hide()\n//   } else {\n//     state.tooltips.show()\n//   }\n// }\n\n// const createOnMouseMoveOnceListener = (state: State, listeners) => (): void => {\n//   document.addEventListener('scroll', listeners.onScrollOnce, { once: true })\n//   state.brush.show()\n//   // Call removeDimensions and removePosition to not animate dimensions and position when the highlight becomes\n//   // visible again(ex.after scrolling the page).\n//   state.pageElementHighlight.removeDimensions()\n//   state.pageElementHighlight.removePosition()\n//   state.pageElementHighlight.show()\n// }\n\n// const createOnScrollOnceListener = (state: State, listeners) => (): void => {\n//   document.addEventListener('mousemove', listeners.onMouseMoveOnce, { once: true })\n\n//   state.elementSelector = null\n//   state.brush.hide()\n//   state.pageElementHighlight.hide()\n// }\n\n// const createOnBlurListener = (state: State, listeners, options) => (): void => {\n//   const { pointerSelect } = options\n\n//   document.removeEventListener('mousemove', listeners.onMouseMoveOnce)\n//   document.removeEventListener('mousemove', listeners.onMouseMove)\n//   document.removeEventListener('keydown', listeners.onKeyDownOrMouseClick, true)\n\n//   if (pointerSelect) {\n//     document.removeEventListener('click', listeners.onKeyDownOrMouseClick, true)\n//   }\n\n//   document.removeEventListener('scroll', listeners.onScrollOnce)\n\n//   state.elementSelector = null\n//   state.brush.hide()\n//   state.pageElementHighlight.hide()\n//   state.glass.showFocusRequest()\n// }\n\n// const createOnFocusListener = (state: State, listeners, options) => (): void => {\n//   const { pointerSelect } = options\n\n//   document.addEventListener('mousemove', listeners.onMouseMoveOnce, { once: true })\n//   document.addEventListener('mousemove', listeners.onMouseMove)\n//   document.addEventListener('keydown', listeners.onKeyDownOrMouseClick, true)\n\n//   if (pointerSelect) {\n//     document.addEventListener('click', listeners.onKeyDownOrMouseClick, true)\n//   }\n\n//   state.glass.hideFocusRequest()\n// }\n\n// /**\n//  * Attempts to stop event from propagating further.\n//  * It's required the event listener calling this function is marked as NOT passive.\n//  */\n// const attemptHijackEvent = (event) => {\n//   event.preventDefault()\n//   event.stopImmediatePropagation()\n//   event.stopPropagation()\n// }\n\n// const fireCustomSelectEvent = (elementSelector: string | null, element: Element | null) => {\n//   if (elementSelector === null) {\n//     console.warn('No element selected.')\n//   } else {\n//     console.info('Element picked: ', elementSelector, element)\n\n//     const selectEvent = new CustomEvent(elementSelectEventName, {\n//       detail: {\n//         elementSelector,\n//         element\n//       }\n//     })\n\n//     window.dispatchEvent(selectEvent)\n//   }\n// }\n\n// const createOnKeyDownOrMouseClickListener = (state: State, updateStateElementSelector, options) => (\n//   event: KeyboardEvent | MouseEvent\n// ): void => {\n//   const { hijackEvents, alternativeControls, pointerSelect, hijackPointerEvents } = options\n\n//   if (event instanceof KeyboardEvent) {\n//     if (event.key === 'O' || (alternativeControls && event.key === '-') || (alternativeControls && event.key === '_')) {\n//       // Use _ as alias for -.\n//       const response = handleBrushDecrease({\n//         ...pick(state, ['baseBrushRadius', 'brush', 'lastMouseEvent', 'pageElementHighlight', 'brushRadiusMultiplier']),\n//         elementSelectorChangeCallback: updateStateElementSelector\n//       })\n\n//       Object.assign(state, response)\n\n//       if (hijackEvents) {\n//         attemptHijackEvent(event)\n//       }\n//     } else if (\n//       event.key === 'P' ||\n//       (alternativeControls && event.key === '+') ||\n//       (alternativeControls && event.key === '=')\n//     ) {\n//       // Use = as alias for +.\n//       const response = handleBrushRadiusIncrease({\n//         ...pick(state, ['baseBrushRadius', 'brush', 'lastMouseEvent', 'pageElementHighlight', 'brushRadiusMultiplier']),\n//         elementSelectorChangeCallback: updateStateElementSelector\n//       })\n\n//       Object.assign(state, response)\n\n//       if (hijackEvents) {\n//         attemptHijackEvent(event)\n//       }\n//     } else if (event.key === 'X' || (alternativeControls && event.key === 'Escape')) {\n//       window[scriptKey].destroy()\n\n//       if (hijackEvents) {\n//         attemptHijackEvent(event)\n//       }\n//     } else if (event.key === 'S' || (alternativeControls && event.key === 'Enter')) {\n//       fireCustomSelectEvent(state.elementSelector, state.element)\n\n//       if (hijackEvents) {\n//         attemptHijackEvent(event)\n//       }\n//     }\n//   } else if (event instanceof MouseEvent) {\n//     if (pointerSelect) {\n//       // Assume MouseEvent is a click and not press, mouse up etc.\n//       fireCustomSelectEvent(state.elementSelector, state.element)\n\n//       if (hijackPointerEvents) {\n//         attemptHijackEvent(event)\n//       }\n//     }\n//   }\n// }\n\n// const init = (customOptions: InitOptions) => {\n//   const defaultOptions: InitOptions = {\n//     alternativeControls: true,\n//     tint: '#ff3300'\n//   }\n//   const options: InitOptions = {\n//     ...customOptions,\n//     ...defaultOptions\n//   }\n//   const state = createState({\n//     alternativeControls: options.alternativeControls,\n//     tint: options.tint\n//   })\n\n//   // const updateStateElementSelector = (elementSelector: string, element: Element): void => {\n//   //   state.elementSelector = elementSelector\n//   //   state.element = element\n//   // }\n\n//   // const listeners: any = {}\n\n//   // Extend the listeners object to allow listeners to call each other.\n//   // Object.assign(listeners, {\n//   //   onMouseMove: createOnMouseMoveListener(state, updateStateElementSelector),\n//   //   onMouseMoveOnce: createOnMouseMoveOnceListener(state, listeners),\n//   //   onScrollOnce: createOnScrollOnceListener(state, listeners),\n//   //   onBlur: createOnBlurListener(state, listeners, { pointerSelect: options.pointerSelect }),\n//   //   onFocus: createOnFocusListener(state, listeners, { pointerSelect: options.pointerSelect }),\n//   //   onKeyDownOrMouseClick: createOnKeyDownOrMouseClickListener(state, updateStateElementSelector, {\n//   //     hijackEvents: options.hijackEvents,\n//   //     alternativeControls: options.alternativeControls,\n//   //     pointerSelect: options.pointerSelect,\n//   //     hijackPointerEvents: options.hijackPointerEvents\n//   //   })\n//   // })\n\n//   appendAllTo(values(pick(state, ['glass', 'brush', 'pageElementHighlight', 'tooltips'])), document.body)\n\n//   state.brush.setRadius(state.baseBrushRadius)\n\n//   // if (document.hasFocus()) {\n//   //   document.addEventListener('mousemove', listeners.onMouseMoveOnce, { once: true })\n//   //   document.addEventListener('mousemove', listeners.onMouseMove)\n//   //   document.addEventListener('keydown', listeners.onKeyDownOrMouseClick, true)\n\n//   //   if (options.pointerSelect) {\n//   //     document.addEventListener('click', listeners.onKeyDownOrMouseClick, true)\n//   //   }\n//   // } else {\n//   //   state.glass.showFocusRequest()\n//   // }\n\n//   // window.addEventListener('blur', listeners.onBlur)\n//   // window.addEventListener('focus', listeners.onFocus)\n\n//   return {\n//     destroy: (): void => {\n//       // document.removeEventListener('mousemove', listeners.onMouseMoveOnce)\n//       // document.removeEventListener('mousemove', listeners.onMouseMove)\n//       // document.removeEventListener('keydown', listeners.onKeyDownOrMouseClick, true)\n\n//       // document.removeEventListener('click', listeners.onKeyDownOrMouseClick, true)\n\n//       // document.removeEventListener('scroll', listeners.onScrollOnce)\n//       // window.removeEventListener('blur', listeners.onBlur)\n//       // window.removeEventListener('focus', listeners.onFocus)\n\n//       removeAll(values(pick(state, ['glass', 'brush', 'pageElementHighlight', 'tooltips'])))\n//     }\n//   }\n// }\n\nconst create = (customOptions: any) => {\n  // TODO: Replace any\n  const defaultOptions = CONFIG.defaultCreateOptions\n  const options = {\n    ...defaultOptions,\n    ...customOptions\n  }\n\n  let instance = null\n\n  return {\n    init: (): void => {\n      if (instance) {\n        instance.destroy()\n      }\n\n      // TODO: Create Preact app here\n\n      // FIXME: instance = init(options)\n    },\n    isActive: (): boolean => {\n      return instance !== null\n    },\n    destroy: (): void => {\n      if (instance) {\n        // TODO: Remove Preact app here\n        // instance.destroy()\n        instance = null\n      }\n    }\n  }\n}\n\nexport { create }\n"],"sourceRoot":""}